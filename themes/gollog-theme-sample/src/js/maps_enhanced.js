/**
 * DO NOT EDIT THIS FILE.
 * See the following change record for more information,
 * https://www.drupal.org/node/2815083
 * @preserve
 **/

(function ($, Drupal) {
    let behaviorAttached = false;

    Drupal.behaviors.golMapsTabSelector = {
        attach: async function (context) {
            if (!behaviorAttached) {

                behaviorAttached = true;
                let places = []

                $(document).ready(function () {

                    var selected_country = 'Brasil'
                    var selected_state = ''
                    var selected_index = 0

                    // Verifica se o elemento jÃƒÂ¡ foi processado antes de prosseguir
                    const FetchPlaces = fetch('/documents/d/guest/maps_enhanced').then(response => response.json());

                    FetchPlaces.then(function (data) {
                        //Define global var places with data
                        places = data

                        //Populate countries on HTML
                        PopulateCountries(data)

                        //Populate states on HTML
                        PopulateStates(data)

                        //Populate cities on HTML
                        PopulateCities(data)
                    });

                    //Focus and Scroll an country element inside <ul>
                    function scrollToCountry(countryName) {
                        //Disable touch and click
                        $('tab-country-selector-container').css('point-events', 'none');

                        // Find element children that contains text of countryName
                        var countryList = $('.tab-list-country .tab-country-selector');
                        var countryElement = countryList.find('li:contains("' + countryName + '")');

                        if (countryElement.length > 0) {
                            // Mark element with selected class
                            $(".tab-country-item").removeClass("selected-country-item");
                            countryElement.addClass("selected-country-item");

                            // Get the index of element inside <ul>
                            getIndexOfCountry(countryName);

                            // Calculate position of element inside tab-list-country
                            var parent = $('.tab-list-country');
                            var parentOffset = parent.offset().left;
                            var parentWidth = parent.width();
                            var elementOffset = countryElement.offset().left;
                            var elementWidth = countryElement.outerWidth();

                            // Define a variÃ¡vel screenWidth antes de utilizÃ¡-la
                            var screenWidth = $(window).width();

                            var scrollAmount = elementOffset - parentOffset - (parentWidth / 2) + (elementWidth / 2);

                            // Scroll horizontally to position element within view
                            // Reset point-events to enable touch and click
                            if (screenWidth < 765) {
                                parent[0].scrollBy({
                                    left: scrollAmount,
                                    behavior: 'smooth'
                                });
                            } else {
                                scrollAmount = elementOffset - parentOffset;
                                parent[0].scrollTo({
                                    left: scrollAmount,
                                    behavior: 'smooth'
                                });
                            }

                            $('tab-country-selector-container').css('point-events', 'auto');
                            $('.tab-state-name').text('');
                        }


                    }

                    //Focus and Scroll and index of country element inside <ul>
                    function scrollToIndexCountry(index) {
                        var countryList = $('.tab-country-item');
                        var countryName = countryList.eq(index).first().text()

                        selected_country = countryName

                        PopulateStates(places)

                        scrollToCountry(countryName)
                        selected_index = index
                    }

                    //Get index of countryName
                    function getIndexOfCountry(countryName) {
                        //Get the index of element inside <ul>
                        $('.tab-country-item').each(function (index) {
                            if ($(this).text() === countryName) {
                                selected_index = index;
                                return false; // Interrompe o loop apÃƒÂ³s encontrar o elemento 'go'
                            }
                        });
                    }

                    //Populate countries on HTML
                    function PopulateCountries(data) {
                        //Remove old countries on HTML
                        $('.tab-country-item').remove()

                        //array of countries
                        var countries = [];

                        //Remove duplicates
                        data
                            .forEach((item) => {
                                var foundedState = countries.find((country) => item.PaisLookupValue === country)

                                if (!foundedState) {
                                    countries.push(item.PaisLookupValue)
                                }
                            })

                        //Populate <ul> HTML element with countries
                        countries
                            .sort()
                            .forEach((country) => {
                                $('.tab-country-selector')
                                    .append(`<li class="tab-country-item"><p class="text-uppercase">${country}</p></li>`)
                            })

                        //Scroll to initial selected_country
                        scrollToCountry(selected_country)

                        //Click country item
                        $(".tab-country-item").on('click', function () {
                            var self = $(this)

                            //Mark element with selected class
                            $(".tab-country-item").removeClass("selected-country-item")
                            $(this).addClass("selected-country-item")

                            //Get name of country selected
                            selected_country = self.first().text()

                            //Scroll to country selected
                            scrollToCountry(self.first().text())

                            //Populate states of country selected
                            PopulateStates(data)
                        })

                        //Scroll to country when click on left arrow
                        $('.tab-country-selector-left-arrow').on('click', function () {

                            var index = selected_index - 1;

                            if (index < 0) {
                                scrollToIndexCountry(0);
                            } else {
                                scrollToIndexCountry(index)
                            }
                            //block scrollbar
                            // $(this).click(false);
                        })

                        //Scroll to country when click on right arrow
                        $('.tab-country-selector-right-arrow').on('click', function () {

                            var index = selected_index + 1;

                            if (index > countries.length - 1) {
                                scrollToIndexCountry(countries.length - 1);
                            } else {
                                scrollToIndexCountry(index)
                            }
                            //block scrollbar
                            // $(this).click(false);
                        })

                    }

                    //Populate states on HTML
                    //Filtered by selected country
                    function PopulateStates(data) {
                        //Erase old states and old cities HTML elements inside <ul>
                        $('.tab-state-item').remove()
                        $(".tab-city-item").remove()

                        //Array of states
                        var _states = []

                        //filter states by selected_country and
                        //remove duplicates
                        data
                            .filter((fItem) => fItem.PaisLookupValue === selected_country)
                            .forEach((item) => {
                                var foundedState = _states.find((state) => item.SiglaEstado === state)

                                if (!foundedState) {
                                    _states.push(item.SiglaEstado)
                                }
                            })

                        //Sort in alphabetically order and
                        //Create HTML <li> elements inside <ul>
                        _states
                            .sort()
                            .forEach((state) => {
                                $('.tab-state-selector').append(`<li class="tab-state-item"><p>${state}</p></li>`)
                            })

                        //Click on state
                        $(".tab-state-item").on('click', function () {
                            var self = $(this)

                            $(".tab-state-item").removeClass("selected-state-item")
                            $(this).addClass("selected-state-item")

                            selected_state = self.first().text()

                            PopulateCities(data, self.first().text())
                        })
                    }

                    //Populate cities on HTML
                    //Filtered by selected state
                    function PopulateCities(_places, state) {
                        //Erase old cities HTML elements inside <ul>
                        $(".tab-city-item").remove()

                        //Array of cities
                        var cities = _places

                        //Filter cities by state and selected_country
                        //Create HTML <li> elements inside <ul>
                        cities
                            .filter((fItem) => fItem.PaisLookupValue === selected_country)
                            .filter((fitem) => fitem.SiglaEstado === state)
                            .forEach((item, index) => {
                                let horarioFuncionamento = item.HorarioFuncionamento.replace(/-/g, '<br/>')

                                if (index === 0) {
                                    $('.tab-state-name').text(item.EstadoLookupValue)
                                }

                                $('.tab-city-selector')
                                    .append(`
                                <li class="tab-city-item">
                                    <h3>${item.Title}</h3>
                                    <p>${item.Endereco}</p>
                                    
                                    <div class="tab-city-show-more">
                                        <p>Mais informações</p>
                                    </div>

                                    <div class="tab-city-more-info">
                                        <hr/>
                                        <div>
                                            <h5>Telefone</h5>
                                            <p>${item.Telefone}</p>
                                        </div>
                                        <hr/>
                                        <div>
                                            <h5>Horário</h5>
                                            <p>${horarioFuncionamento}</p>
                                        </div>
                                    </div>
                                </li>
                            `)
                            })

                        //Div 'Mais informaÃ§Ãµes' click event
                        $('.tab-city-show-more').on('click', function () {
                            var self = $(this)

                            self.next().show()
                            self.hide()
                        })

                    }

                })
            }
        }
    };

})(jQuery, Drupal);;
/**
 * @param {jQuery} $
 */
(function ($) {

    'use strict';

    /**
     * Drupal behavior for Gol Maps.
     */

    let behaviorAttached = false;

    Drupal.behaviors.golMaps = {

        /**
         * Attaches the behavior to the DOM.
         *
         * @param {HTMLElement} context - The context in which the behavior is attached.
         * @param {object} settings - Drupal settings.
         */
        attach: async (context, settings) => {


            if (!behaviorAttached) {

                behaviorAttached = true;

                // Fetch places data from '/gol-maps/json' endpoint.
                const places = await fetch('/documents/d/guest/maps_enhanced').then(response => response.json());

                // // Call functions to initialize the map and filter.
                getGeolocation(places);

            }

        }

    };


    async function getAddress(address, places) {

        let searchStr = address;

        if(places!==null){
            const result = places.filter(e=>{
                var cleanAddress = address.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
                return e.SearchString.indexOf(cleanAddress.toLowerCase()) !== -1;
            });

            if(result.length > 0){
                searchStr += "," + result[0].EstadoLookupValue;
            }
        }

        const endPoint = window.location.origin+'/places?p_p_id=googleapis_WAR_googleapis&p_p_lifecycle=2&p_p_state=normal&p_p_mode=view&p_p_resource_id=geocode&p_p_cacheability=cacheLevelPage'
        const response = await fetch(endPoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: `address=${encodeURIComponent(searchStr)}`
        });
        return await response.json();
    }

    /**
     * Gets the user's geolocation and initializes the map.
     *
     * @param {Array} places - Array of places data.
     */
    async function getGeolocation(places) {

        if(document.getElementById('gol-maps') != null) {
            // Check if the browser supports geolocation.
            if ('geolocation' in navigator) {
                // Request the user's location.
                navigator.geolocation.getCurrentPosition ((position) => {

                    // User's current location coordinates.
                    const currentLocation = {
                        lat: position.coords.latitude,
                        lng: position.coords.longitude
                    };

                    // Initialize the map with the user's location.
                    initMap (places, currentLocation);

                }, async (error) => {

                    // Initialize the map with the user's location.
                    const defaultPlace = await getAddress ('Brazil', null);

                    await initMap (places, defaultPlace.location, 6);

                    console.error ('Geolocation not supported by the browser');

                    console.info ('Error obtaining location: ' + error.message);
                });

                return;

            }

            // Geolocation not supported by the browser.
        }
    }

    /**
     * Adds an event listener to the search form for address lookup.
     *
     * @param {Array} places - Array of places data.
     * @param {google.maps.Marker} userMarker - Marker for the user's location on the map.
     * @param {google.maps.Map} map - Google Map object.
     */
    async function searchAddress(places, userMarker, map) {

        //Disabled search button
        const searchButton = document.getElementById('search-place-button');

        searchButton.setAttribute('disabled', true);

        const addressInput = document.getElementsByName('address')[0]

        addressInput.addEventListener('input', (e) => e.target.value !== '' ? searchButton.removeAttribute('disabled') : searchButton.setAttribute('disabled', true))

        // Get the search form element.
        const searchForm = document.getElementById('search-address');

        // Add a submit event listener to the search form.
        searchForm.addEventListener('submit', async (e) => {

            e.preventDefault();

            // Get the address from the form data.
            const address = new FormData(searchForm).get('address');

            // Fetch place details based on the address.
            //const result = await getAddress(address)
            const result = await getAddress(address, places);

            // Update the map state with the new place details.
            updateMapState(result, places, userMarker, map);
            //updateMapState(address, places, userMarker, map);
        });
    }

    /**
     * Updates the map state with new place details.
     *
     * @param {object} result - Place details obtained from address search.
     * @param {Array} places - Array of places data.
     * @param {google.maps.Marker} userMarker - Marker for the user's location on the map.
     * @param {google.maps.Map} map - Google Map object.
     */
    function updateMapState(result, places, userMarker, map) {
    //function updateMapState(address, places, userMarker, map) {

        if (result !== 'ZERO_RESULTS') {

            const LIMIT_RADIUS = 20;

            let placesWithDistance = [];

            // Calculate distances between the user's location and each place.
            places.forEach((place) => {
                placesWithDistance.push(distanceCalculator(result.location, { lat: place.latitude, lng: place.longitude }, place));
            });

            //const result = places.filter(e=>{
            //    var cleanAddress = address.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
            //    return e.SearchString.indexOf(cleanAddress.toLowerCase()) !== -1;
            //});

            // Sort places by distance in ascending order.
            //const placesByAsc = result
            const placesByAsc = placesWithDistance
                .sort((a, b) => a.distance - b.distance);
            //    .filter(place => place.distance <= LIMIT_RADIUS);

            // Update the list of places with the closest ones.
            //updatePlacesList(placesByAsc);

            //const latLng = {
            //    lat: parseFloat(placesByAsc[0].latitude),
            //    lng: parseFloat(placesByAsc[0].longitude)
            //};

            // Pan the map to the new location.
            //map.panTo(latLng);
            map.panTo(result.location);

            // Set the position of the user's marker on the map.
            //userMarker.setPosition(latLng);
            userMarker.setPosition(result.location);

            return;
        }

        // Get the HTML element for the places list.
        const placesList = document.getElementById('places-list');

        //Reset places when the result is empty
        updatePlacesList([]);

        placesList.innerHTML = `<div>
            <h4>Endereço inválido</h4>
            <p>
            A busca não póde ser concluída, pois o endereço digitado 
            não corresponde a nenhum endereço existente. 
            Por favor, verifique novamente se o endereço foi inserido de forma correta.
            </p>
          </div> `;

    }

    /**
     * Initializes the Google Map with markers and user's location.
     *
     * @param {Array} places - Array of places data.
     * @param {object} location - User's current location coordinates.
     * @param {int} initialZoom - Initial map zoom
     */
    function initMap(places, location, initialZoom = 12) {

        // Create a new Google Map instance.
        const map = new google.maps.Map(document.getElementById('gol-maps'), {

            zoom: initialZoom,
            center: new google.maps.LatLng(location),
            mapTypeId: google.maps.MapTypeId.ROADMAP,
            mapTypeControl: false,
            streetViewControl: false,
            enableCloseButton: false,
            fullScreenControl: false,
            disableDefaultUI: false,

        });

        // Create a marker for the user's location.
        const userMarker = new google.maps.Marker({
            map: map,
            title: 'Your Current Location',
        });

        // Set the position of the user's marker on the map.
        userMarker.setPosition(location);

        map.setOptions({ styles: [{ featureType: 'poi', stylers: [{ visibility: 'off' }] }] });

        // Attach event listeners for address search and marker creation.
        searchAddress(places, userMarker, map);
        createMarker(places, map);
    }

    /**
     * Creates markers on the map for each place in the array.
     *
     * @param {Array} places - Array of places data.
     * @param {google.maps.Map} map - Google Map object.
     */
    function createMarker(places, map) {

        // Create an info window for displaying place details.
        const infoWindow = new google.maps.InfoWindow();

        // Iterate through each place and create a marker on the map.
        places.forEach((place) => {

            const marker = new google.maps.Marker({
                position: new google.maps.LatLng(place.latitude, place.longitude),
                map: map,
                title: place.Title,
                icon: '/o/gollog-theme/images/modules/custom/gol_maps/assets/images/marker.png'
            });

            // Add a click event listener to each marker.
            marker.addListener('click', function () {

                // Close the currently open info window, if any.
                if (infoWindow) infoWindow.close();

                // Create the content for the info window.
                const content = `
        <h3>${place.Title}</h3>
        <p>${place.Endereco}</p>
        <hr class="m-3" />
        <h4>Contatos</h4>
        <p>${place.Telefone}</p>
        <p>${place.Email.split(':')[1]}</p>
        <p>${place.HorarioFuncionamento}</p>
      `
                // Open the new info window.
                infoWindow.setContent(content);
                infoWindow.open(map, marker);

            });
        });
    }

    /**
     * Calculates the distance between two locations using the Haversine formula.
     *
     * @param {object} location1 - Coordinates of the first location.
     * @param {object} location2 - Coordinates of the second location.
     * @param {object} place - Place data.
     * @returns {object} - Place data with added distance property.
     */
    function distanceCalculator(location1, location2, place) {

        const R = 6371; // Earth's radius in kilometers

        // Convert degrees to radians.
        const toRad = (value) => value * Math.PI / 180;

        // Calculate differences in latitude and longitude.
        const dLat = toRad(location2.lat - location1.lat);
        const dLon = toRad(location2.lng - location1.lng);

        // Haversine formula for distance calculation.
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(toRad(location1.lat)) * Math.cos(toRad(location2.lat)) *
            Math.sin(dLon / 2) * Math.sin(dLon / 2);

        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        // Calculate distance and round to 2 decimal places.
        const distance = R * c;
        place.distance = Math.round(distance * 100) / 100;

        return place;
    }

    /**
     * Updates the list of places with distances.
     *
     * @param {Array} placesWithDistance - Array of places with distances.
     */
    function updatePlacesList(placesWithDistance) {

        // Get the HTML element for the places list.
        const placesList = document.getElementById('places-list');

        const resultInfo = document.getElementById('result-label');

        resultInfo.innerHTML = ''

        let resultText = placesWithDistance.length > 1 ? 'resultados encontrados em' : 'resultado encontrado em';

        const appendText = placesWithDistance.length > 0 ?
            `${placesWithDistance.length} ${resultText} ${placesWithDistance[0].SiglaEstado}` : `${placesWithDistance.length} lojas encontradas.`

        resultInfo.append(appendText)

        // Clear the existing list items.
        placesList.innerHTML = '';

        // Add new list items for each place with distance information.

        if (placesWithDistance.length > 0) {

            placesWithDistance.forEach((place, i) => {
                const listItem = document.createElement('li');
                listItem.className = 'place-item'
                listItem.innerHTML += `
         <div>
         <h3>${place.Title}</h3>
         <p>${place.Endereco}</p>
         <!--<p>Distância do endereço: ${place.distance} km</p>-->
         <span class="more-info" id="more-info${i}">Mais informações</span>
         <div class="contact-info-box" id="contact-info-box${i}">
         <h4>Telefone</h4>
         <p>${place.Telefone}</p>
         <h4>Horário</h4>
         <p class="pb-0">${place.HorarioFuncionamento}</p>
         </div> 
         </div>
        `;

                placesList.appendChild(listItem);

                const moreInfoButton = document.getElementById(`more-info${i}`);

                if (moreInfoButton) {
                    document.getElementById(`more-info${i}`).addEventListener('click', () => {
                        $(`#contact-info-box${i}`).toggle();
                    })

                }

            });

            return;

        }

        placesList.innerHTML = `<div>
    <h4>Nenhuma loja encontrada próxima ao endereço inserido</h4>
    <p>
      Parece que ainda não temos uma loja nas proximidades do endereço que 
      você digitou. Por favor, verifique novamente se o endereço 
      foi inserido corretamente para garantir a precisão da busca.
    </p>
  </div> `;

    }

})(jQuery);
;

Drupal.debounce = function (func, wait, immediate) {
    var timeout = void 0;
    var result = void 0;
    return function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var context = this;
        var later = function later() {
            timeout = null;
            if (!immediate) {
                result = func.apply(context, args);
            }
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) {
            result = func.apply(context, args);
        }
        return result;
    };
};;
!function(i,n,s){"use strict";function l(l,t){function e(i){if(g.find(".b-lazy:not(.b-loaded)").length){var s=g.find(i?".slide:not(.slick-cloned) .b-lazy:not(.b-loaded)":".slick-active .b-lazy:not(.b-loaded)");s.length||(s=g.find(".slick-cloned .b-lazy:not(.b-loaded)")),s.length&&n.blazy.init.load(s)}}function a(){b&&r(),y&&e(!1)}function o(n){var s=i(n),l=s.closest(".slide")||s.closest(".unslick");s.parentsUntil(l).removeClass(function(i,n){return(n.match(/(\S+)loading/g)||[]).join(" ")});var t=s.closest(".media--background");t.length&&t.find("> img").length&&(t.css("background-image","url("+s.attr("src")+")"),t.find("> img").remove(),t.removeAttr("data-lazy"))}function d(){g.children().sort(function(){return.5-Math.random()}).each(function(){g.append(this)})}function c(i){var n=i.slideCount<=i.options.slidesToShow,s=n||!1===i.options.arrows;if(g.attr("id")===i.$slider.attr("id")){i.options.centerPadding&&"0"!==i.options.centerPadding||i.$list.css("padding",""),n&&i.$slideTrack.width()<=i.$slider.width()&&i.$slideTrack.css({left:"",transform:""});var l=g.find(".b-loaded ~ .b-loader");l.length&&l.remove(),p[s?"addClass":"removeClass"]("visually-hidden")}}function r(){g.removeClass("is-paused"),g.find(".is-playing").length&&g.find(".is-playing").removeClass("is-playing").find(".media__icon--close").click()}function u(){g.addClass("is-paused").slick("slickPause")}function f(s){return _?{}:{slide:s.slide,lazyLoad:s.lazyLoad,dotsClass:s.dotsClass,rtl:s.rtl,prevArrow:i(".slick-prev",p),nextArrow:i(".slick-next",p),appendArrows:p,customPaging:function(i,l){var t=i.$slides.eq(l).find("[data-thumb]")||null,e='<img alt="'+n.t(t.find("img").attr("alt"))+'" src="'+t.data("thumb")+'">',a=t.length&&s.dotsClass.indexOf("thumbnail")>0?'<div class="slick-dots__thumbnail">'+e+"</div>":"",o=i.defaults.customPaging(i,l);return a?o.add(a):o}}}var k,g=i("> .slick__slider",t).length?i("> .slick__slider",t):i(t),p=i("> .slick__arrow",t),h=g.data("slick")?i.extend({},s.slick,g.data("slick")):i.extend({},s.slick),m=!("array"!==i.type(h.responsive)||!h.responsive.length)&&h.responsive,v=h.appendDots,y="blazy"===h.lazyLoad&&n.blazy,b=g.find(".media--player").length,_=g.hasClass("unslick");if(_||(h.appendDots=".slick__arrow"===v?p:v||i(g)),m)for(k in m)Object.prototype.hasOwnProperty.call(m,k)&&"unslick"!==m[k].settings&&(m[k].settings=i.extend({},s.slick,f(h),m[k].settings));g.data("slick",h),h=g.data("slick"),function(){h.randomize&&!g.hasClass("slick-initiliazed")&&d(),_||g.on("init.sl",function(s,l){".slick__arrow"===v&&i(l.$dots).insertAfter(l.$prevArrow);var t=g.find(".slick-cloned.slick-active .b-lazy:not(.b-loaded)");y&&t.length&&n.blazy.init.load(t)}),y?g.on("beforeChange.sl",function(){e(!0)}):i(".media",g).closest(".slide__content").addClass("is-loading"),g.on("setPosition.sl",function(i,n){c(n)})}(),g.slick(f(h)),function(){g.parent().on("click.sl",".slick-down",function(n){n.preventDefault();var s=i(this);i("html, body").stop().animate({scrollTop:i(s.data("target")).offset().top-(s.data("offset")||0)},800,"easeOutQuad"in i.easing&&h.easing?h.easing:"swing")}),h.mouseWheel&&g.on("mousewheel.sl",function(i,n){return i.preventDefault(),g.slick(n<0?"slickNext":"slickPrev")}),y||g.on("lazyLoaded lazyLoadError",function(i,n,s){o(s)}),g.on("afterChange.sl",a),b&&(g.on("click.sl",".media__icon--close",r),g.on("click.sl",".media__icon--play",u))}(),_&&g.slick("unslick"),i(t).addClass("slick--initialized")}n.behaviors.slick={attach:function(n){i(".slick",n).once("slick").each(l)}}}(jQuery,Drupal,drupalSettings);
;
window.matchMedia||(window.matchMedia=function(){"use strict";var e=window.styleMedia||window.media;if(!e){var t=document.createElement("style"),i=document.getElementsByTagName("script")[0],n=null;t.type="text/css";t.id="matchmediajs-test";i.parentNode.insertBefore(t,i);n="getComputedStyle"in window&&window.getComputedStyle(t,null)||t.currentStyle;e={matchMedium:function(e){var i="@media "+e+"{ #matchmediajs-test { width: 1px; } }";if(t.styleSheet){t.styleSheet.cssText=i}else{t.textContent=i}return n.width==="1px"}}}return function(t){return{matches:e.matchMedium(t||"all"),media:t||"all"}}}());
;
/**
 * @file
 * Carousel.
 *
 */
(function ($, Drupal) {
    'use strict';

    Drupal.behaviors.block_slick_carousel = {
        attach: function (context) {
            $(context).find('.block-content-reference-carrossel').once('custom-select-route').each(
                function() {
                    if ($(this).find('.field--name-field-hc-img-desk').length == 0) {
                        $(this).find('nav.slick__arrow').addClass('slider-arrow-new');
                    }
                }
            );
        }
    }

    $( document ).ready(function() {
        if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {
            var textSided = $('.field--name-field-hc-text-half-carousel');
            let filledCar = $('.carousel-filled');

            if(textSided){
                var item = $('.carousel-sided');
                var height = $(item[0]).closest('.slick__slide').height();
                var exchange = ((height - 200) / 2 ) * -1;
                $(item[0]).parents('.slick--field-hc-item').find('.slick-prev').css("margin-top", exchange);
                $(item[0]).parents('.slick--field-hc-item').find('.slick-next').css("margin-top", exchange);
            }
            if(window.matchMedia("(max-width: 767px)").matches){
                if(filledCar){
                    $('.slick-prev').addClass('arrow-prev-filled');
                    $('.slick-next').addClass('arrow-next-filled');
                }
            }
        }
    });

})(jQuery, Drupal);
;
/**
 * @file
 * Acessibility.
 *
 */
(function ($, Drupal, drupalSettings, window) {
    "use strict";

    Drupal.behaviors.acessibility = {
        attach: function (context, settings) {
            var $html = $("html");

            var theme_voegol = $(context)
                .find("html.theme-default")
                .once("theme-processed");
            if (theme_voegol.length) {
                if (drupalSettings.acessibility.theme_highcontrast) {
                    $html.addClass("theme-highcontrast").removeClass("theme-default");
                }
                else {
                    var localTheme =
                        window.localStorage.getItem("theme") || "theme-default";
                    if (localTheme !== "theme-default") {
                        $html.addClass("theme-highcontrast").removeClass("theme-default");
                    }
                }
            }

            $(".acessibility-menu__button", context)
                .once("acessibility-processed")
                .click(function () {
                    var current_theme = $html.hasClass("theme-default")
                        ? "theme-default"
                        : "theme-highcontrast";
                    $html.toggleClass("theme-default").toggleClass("theme-highcontrast");
                    window.localStorage.setItem(
                        "theme",
                        current_theme == "theme-default"
                            ? "theme-highcontrast"
                            : "theme-default"
                    );
                });
        },
    };
})(jQuery, Drupal, drupalSettings, window);
;